---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 114514.
--- DateTime: 2026/2/17 22:02
---
-- ============================
--       配置区域 (Settings)
-- ============================
local toggle_key    = 8           -- 开关脚本的按键 (鼠标侧键 G8)
local led_key       = "capslock"  -- 状态指示灯 (capslock / numlock / scrolllock)

-- 你的核心参数
local sleep_1       = 60          -- 第一阶段延迟
local sleep_2       = 50          -- 第二阶段延迟
local max_move      = 20          -- 压枪生效的循环次数

-- 脚本运行状态变量
local is_active     = false       -- 默认关闭

-- 开启监听
EnablePrimaryMouseButtonEvents(true)
ClearLog()
OutputLogMessage("Script Loaded. Logic Optimized.\n")

-- ============================
--       辅助函数
-- ============================

-- 灯光同步函数：确保灯光状态与脚本开启状态一致
function SyncLedState(target_state)
    -- 获取当前键盘灯状态
    local current_state = IsKeyLockOn(led_key)

    -- 如果当前灯光状态与目标不一致，则按一下键来修正
    if current_state ~= target_state then
        PressAndReleaseKey(led_key)
    end
end

-- ============================
--       主逻辑
-- ============================
function OnEvent(event, arg)

    -- 1. 开关切换逻辑
    if (event == "MOUSE_BUTTON_PRESSED" and arg == toggle_key) then
        is_active = not is_active -- 切换状态

        if is_active then
            OutputLogMessage("[Script] ON\n")
            SyncLedState(true)  -- 强制点亮灯光
        else
            OutputLogMessage("[Script] OFF\n")
            SyncLedState(false) -- 强制熄灭灯光
        end
    end

    -- 2. 压枪循环逻辑
    if (event == "MOUSE_BUTTON_PRESSED" and arg == 1 and is_active) then
        -- 再次校验灯光
        -- SyncLedState(true)

        local downcount = 0

        repeat
            downcount = downcount + 1

            -- 只有在计数范围内才执行压枪
            if (downcount <= max_move) then
                -- 阶段 1: 下拉
                MoveMouseRelative(0, 6)
                Sleep(sleep_1)

                -- 阶段 2: 右移
                MoveMouseRelative(3, 0)
                Sleep(sleep_2)

                -- 阶段 3: 左下回拉 (修正/补偿)
                MoveMouseRelative(-2, 6)

                -- 如果感觉压枪太快删除sleep
            else
                -- 当超过 max_move 次数后Sleep防止驱动掉帧
                Sleep(10)
            end

        until not IsMouseButtonPressed(1) -- 直到松开左键
    end
end