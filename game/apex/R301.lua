---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 114514.
--- DateTime: 2026/2/17 21:07
---
-- ============================
--       配置区域 (Settings)
-- ============================
local toggle_key   = 8           -- 开关脚本的按键 (鼠标侧键 G8)
local led_key      = "capslock"  -- 用于指示状态的灯 (capslock / numlock / scrolllock)
local sleep_press  = 12          -- 抖动按下后的延迟
local sleep_recover= 22          -- 抖动恢复后的延迟
local jitter_min   = 3           -- 抖动最小像素
local jitter_max   = 4           -- 抖动最大像素
local max_pull_time= 50          -- 垂直压枪的最大循环次数

-- 脚本初始变量
local is_active    = false       -- 脚本默认为关闭状态

-- 开启鼠标左键监听
EnablePrimaryMouseButtonEvents(true)
ClearLog()
OutputLogMessage("Script Loaded. Use G%d to toggle.\n", toggle_key)

-- ============================
--       辅助函数
-- ============================

-- 强制同步灯光状态函数
-- target_state: true (灯亮) / false (灯灭)
function SyncLedState(target_state)
    local current_state = IsKeyLockOn(led_key)

    -- 只有当 "当前状态" 不等于 "目标状态" 时，才模拟按键
    if current_state ~= target_state then
        PressAndReleaseKey(led_key)
    end
end

-- ============================
--       主逻辑
-- ============================
function OnEvent(event, arg)
    -- 1. 切换开关
    if (event == "MOUSE_BUTTON_PRESSED" and arg == toggle_key) then
        is_active = not is_active -- 切换 true/false

        if is_active then
            OutputLogMessage("[Script] ON (Syncing LED...)\n")
            SyncLedState(true) -- 强制点亮
        else
            OutputLogMessage("[Script] OFF (Syncing LED...)\n")
            SyncLedState(false) -- 强制熄灭
        end
    end

    -- 2. 射击
    if (event == "MOUSE_BUTTON_PRESSED" and arg == 1 and is_active) then
        -- 再次校验：防止用户在开启脚本后手动把灯关了
        -- 如果你希望更加严谨，可以取消下面这行的注释，每次开火前都会强制检查一次灯光
        -- SyncLedState(true)

        local pull_counter = 0

        repeat
            -- 垂直压枪
            if (pull_counter <= max_pull_time) then
                MoveMouseRelative(0, 1)
                pull_counter = pull_counter + 1
            end

            -- 抖动逻辑
            local offset = math.random(jitter_min, jitter_max)

            -- 向右下移动
            MoveMouseRelative(offset, offset)
            Sleep(sleep_press)

            -- 向左上回正
            MoveMouseRelative(-offset, -offset)
            Sleep(sleep_recover)

        until not IsMouseButtonPressed(1)
    end
end